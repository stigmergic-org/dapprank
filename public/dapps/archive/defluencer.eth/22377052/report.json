{
  "version": 2,
  "contentHash": "bafybeid4bnfhgapf6q7aqp4kpdwafkiab4fz5sghxafrekvbkfnythylpa",
  "timestamp": 1745957947,
  "blockNumber": 22377052,
  "rootMimeType": "inode/directory",
  "totalSize": 7892429,
  "favicon": "favicon.png",
  "title": "Defluencers",
  "distributionPurity": {
    "externalScripts": [],
    "externalMedia": []
  },
  "networkingPurity": [
    {
      "file": "index-4d4db931f7812dd5.js",
      "occurences": [
        {
          "method": "fetch",
          "urls": [],
          "library": "wasm-bindgen",
          "type": "rpc",
          "motivation": "```javascript\nimports.wbg.__wbg_fetch_01d048dd000bcda1 = function(arg0) {\n    var ret = fetch(getObject(arg0));\n    return addHeapObject(ret);\n};\nimports.wbg.__wbg_fetch_b4e81012e07ff95a = function(arg0, arg1) {\n    var ret = getObject(arg0).fetch(getObject(arg1));\n    return addHeapObject(ret);\n};\n```\n* The code defines WASM imports (`__wbg_fetch_01d048dd000bcda1`, `__wbg_fetch_b4e81012e07ff95a`) that directly wrap the global `fetch` function. These are designed to be called from the WASM module.\n* Given the import of `get_provider_js` and the general Web3 context established by other imports (like `.request`), these `fetch` calls are most likely used by the WASM logic to make JSON-RPC calls to an Ethereum node.\n* The specific URL is determined dynamically within the WASM code (passed via `getObject(arg0)` or `getObject(arg1)`) based on configuration or provider details and is not visible in this JavaScript glue code."
        },
        {
          "method": "fetch",
          "urls": [
            "index-4d4db931f7812dd5_bg.wasm"
          ],
          "library": "None",
          "type": "self",
          "motivation": "```javascript\nasync function init(input) {\n    if (typeof input === 'undefined') {\n        input = new URL('index-4d4db931f7812dd5_bg.wasm', import.meta.url);\n    }\n    // ...\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n    const { instance, module } = await load(await input, imports);\n    // ...\n}\n```\n* The `init` function, responsible for loading the WebAssembly module, uses `fetch(input)` if the provided `input` is a string, URL, or Request object.\n* If `input` is initially undefined, it defaults to `new URL('index-4d4db931f7812dd5_bg.wasm', import.meta.url)`, indicating a fetch for the WASM binary relative to the current script's location."
        }
      ]
    }
  ],
  "libraryUsage": [
    {
      "file": "index-4d4db931f7812dd5.js",
      "occurences": [
        {
          "name": "wasm-bindgen",
          "motivation": "```javascript\nimports.wbg = {};\nimports.wbg.__wbindgen_object_drop_ref = function(arg0) { ... };\n// ... many other __wbindgen_ functions\nwasm = instance.exports;\ninit.__wbindgen_wasm_module = module;\nwasm.__wbindgen_start();\n```\n* The code heavily features functions prefixed with `__wbindgen_` and `__wbg_`, along with heap management (`heap`, `addHeapObject`, `getObject`, `takeObject`) and memory views (`getUint8Memory0`, `getInt32Memory0`). This is the characteristic structure of JavaScript glue code generated by the Rust `wasm-bindgen` tool to interact with a WebAssembly module compiled from Rust."
        },
        {
          "name": "Web3 Interaction Library (via WASM/Provider)",
          "motivation": "```javascript\nimport { get_provider_js } from './snippets/web3-81b2b3878aa3e2f1/inline0.js';\n// ...\nimports.wbg.__wbg_getproviderjs_e61b5f18bbc3a358 = function() { return handleError(function () {\n    var ret = get_provider_js();\n    return isLikeNone(ret) ? 0 : addHeapObject(ret);\n}, arguments) };\nimports.wbg.__wbg_request_09c67bc34f5d7fbf = function() { return handleError(function (arg0, arg1) {\n    var ret = getObject(arg0).request(RequestArguments.__wrap(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n```\n* The code imports and uses a function `get_provider_js` from a file path containing 'web3'.\n* It defines a WASM import (`__wbg_getproviderjs_...`) that calls this function.\n* It defines another WASM import (`__wbg_request_...`) that calls the standard EIP-1193 `.request()` method on an object (presumably the provider obtained via `get_provider_js`), passing structured `RequestArguments`. This indicates interaction with an Ethereum provider (like MetaMask or an RPC endpoint) for sending JSON-RPC requests."
        },
        {
          "name": "WASM Streams Helper",
          "motivation": "```javascript\nimport { bytes_literal } from './snippets/wasm-streams-4699ae6298bd1aae/inline0.js';\n// ...\nimports.wbg.__wbg_bytesliteral_e3628d8ef7e9bf0e = function() {\n    var ret = bytes_literal();\n    return addHeapObject(ret);\n};\n// ... other stream related classes like IntoUnderlyingByteSource, IntoUnderlyingSink etc.\n```\n* The code imports `bytes_literal` from a path mentioning `wasm-streams`.\n* It defines WASM-related classes (`IntoUnderlyingByteSource`, `IntoUnderlyingSink`, `IntoUnderlyingSource`, `PipeOptions`, etc.) that mirror the Web Streams API, suggesting a library or generated code to facilitate stream handling between JavaScript and the WASM module."
        }
      ]
    }
  ],
  "urls": [],
  "ethereum": [
    {
      "file": "snippets/web3-81b2b3878aa3e2f1/inline0.js",
      "occurences": [
        {
          "count": 1
        }
      ]
    }
  ],
  "fallbacks": [
    {
      "file": "index-4d4db931f7812dd5.js",
      "occurences": [
        {
          "type": "rpc",
          "motivation": "```javascript\nimport { get_provider_js } from './snippets/web3-81b2b3878aa3e2f1/inline0.js';\n// ...\nimports.wbg.__wbg_location_f98ad02632f88c43 = function(arg0) {\n    var ret = getObject(arg0).location;\n    return addHeapObject(ret);\n};\nimports.wbg.__wbg_search_f44353b4fdbdd216 = function() { return handleError(function (arg0, arg1) {\n    var ret = getObject(arg1).search;\n    // ... returns search string to WASM\n}, arguments) };\n```\n* The code imports a `get_provider_js` function, presumably for obtaining an EIP-1193 provider.\n* It also provides access to `window.location` and specifically `window.location.search` to the WASM module.\n* Standard implementations of provider logic (like those found in libraries such as ethers.js, or custom implementations interacting with `get_provider_js`) often check `window.location.search` for query parameters like `?ds-rpc-<CHAIN_ID>=url` to allow users to specify fallback or alternative RPC endpoints.\n* While the parsing logic isn't explicitly visible in *this* JavaScript file (it's likely within the imported `get_provider_js` or the WASM module itself), the provision of the search string to the Web3/WASM layer strongly suggests that this standard fallback mechanism is supported."
        }
      ]
    }
  ]
}